#ifndef RAYTRACER_KERNEL_H
#define RAYTRACER_KERNEL_H

#ifdef __APPLE__
#include <OpenCL/opencl.h>
#else
#include <CL/cl.h>
#endif

#include <string.h>
#include <stdio.h>

const char* kernelSource =
"#define uint32_t uint\n"
"#define PI 3.14159265358979323846f\n"
"#define MAX(X, Y) (((X) > (Y)) ? (X) : (Y))\n"
"float math_clamp(float in, float min, float max) {\n"
"    return in < min ? min : (in > max ? max : in);\n"
"}\n"
"\n"
"float math_deg2rad(float deg) {\n"
"    return deg * (PI/180.f);\n"
"}\n"
"\n"
"float math_rad2deg(float rad) {\n"
"    return rad * (180.f/PI);\n"
"}"
""
"float random_unilateral() {\n"
"    return 0;\n"
"}\n"
"\n"
"float random_bilateral() {\n"
"    return -1.0f + 2.0f * random_unilateral();\n"
"}"
""
"typedef union {\n"
"    struct {\n"
"        float x, y, z;\n"
"    };\n"
"    struct {\n"
"        float r, g, b;\n"
"    };\n"
"} Vec3;\n"
"\n"
"Vec3 vec3_add(Vec3 a, Vec3 b);\n"
"Vec3 vec3_sub(Vec3 a, Vec3 b);\n"
"float vec3_dot(Vec3 a, Vec3 b);\n"
"Vec3 vec3_cross(Vec3 a, Vec3 b);\n"
"Vec3 vec3_clamp(Vec3 a, float min, float max);\n"
"Vec3 vec3_hadamard(Vec3 a, Vec3 b);\n"
"Vec3 vec3_norm(Vec3 a);\n"
"float vec3_length(Vec3 a);\n"
"Vec3 vec3_offset(Vec3 a, float offset);\n"
"Vec3 vec3_mul(Vec3 a, float b);\n"
"Vec3 vec3_div(Vec3 a, float b);\n"
"Vec3 vec3_reflect(Vec3 incomingVec, Vec3 normal);"
""
"Vec3 vec3_add(Vec3 a, Vec3 b) {\n"
"    a.x += b.x;\n"
"    a.y += b.y;\n"
"    a.z += b.z;\n"
"    return a;\n"
"}\n"
"\n"
"Vec3 vec3_sub(Vec3 a, Vec3 b) {\n"
"    a.x -= b.x;\n"
"    a.y -= b.y;\n"
"    a.z -= b.z;\n"
"    return a;\n"
"}\n"
"\n"
"float vec3_dot(Vec3 a, Vec3 b) {\n"
"    return a.x * b.x + a.y * b.y + a.z * b.z;\n"
"}\n"
"\n"
"Vec3 vec3_cross(Vec3 a, Vec3 b) {\n"
"    Vec3 result;\n"
"    result.x = a.y * b.z - a.z * b.y;\n"
"    result.y = a.z * b.x - a.x * b.z;\n"
"    result.z = a.x * b.y - a.y * b.x;\n"
"    return result;\n"
"}\n"
"\n"
"Vec3 vec3_clamp(Vec3 a, float min, float max) {\n"
"    a.r = math_clamp(a.r, min, max);\n"
"    a.g = math_clamp(a.g, min, max);\n"
"    a.b = math_clamp(a.b, min, max);\n"
"    return a;\n"
"}\n"
"\n"
"Vec3 vec3_hadamard(Vec3 a, Vec3 b) {\n"
"    Vec3 result;\n"
"    result.x = a.x * b.x;\n"
"    result.y = a.y * b.y;\n"
"    result.z = a.z * b.z;\n"
"    return result;\n"
"}\n"
"\n"
"Vec3 vec3_norm(Vec3 a) {\n"
"    float length = vec3_length(a);\n"
"    if (length != 0) {\n"
"        a.x /= length;\n"
"        a.y /= length;\n"
"        a.z /= length;\n"
"    }\n"
"    return a;\n"
"}\n"
"\n"
"float vec3_length(Vec3 a) {\n"
"    return sqrt(a.x * a.x + a.y * a.y + a.z * a.z);\n"
"}\n"
"\n"
"Vec3 vec3_offset(Vec3 a, float offset) {\n"
"    a.x += offset;\n"
"    a.y += offset;\n"
"    a.z += offset;\n"
"    return a;\n"
"}\n"
"\n"
"Vec3 vec3_mul(Vec3 a, float b) {\n"
"    a.x *= b;\n"
"    a.y *= b;\n"
"    a.z *= b;\n"
"    return a;\n"
"}\n"
"\n"
"Vec3 vec3_div(Vec3 a, float b) {\n"
"    a.x /= b;\n"
"    a.y /= b;\n"
"    a.z /= b;\n"
"    return a;\n"
"}\n"
"\n"
"Vec3 vec3_reflect(Vec3 incomingVec, Vec3 normal) {\n"
"    Vec3 reversedVec = vec3_mul(incomingVec, -1);\n"
"    Vec3 reflectedVec = vec3_norm(vec3_sub(vec3_mul(normal, 2.0f * vec3_dot(normal, reversedVec)), reversedVec));\n"
"    return reflectedVec;\n"
"}"
""
""
"typedef struct {\n"
"    Vec3 position;\n"
"    Vec3 x, y, z;\n"
"    Vec3 lookAt;\n"
"    uint32_t width, height;\n"
"    float FOV, aspectRatio;\n"
"    Vec3 renderTargetCenter;\n"
"    float renderTargetWidth, renderTargetHeight, renderTargetDistance;\n"
"} Camera;"
""
"typedef struct {\n"
"\tfloat reflectionIndex;\n"
"\tfloat refractionIndex;\n"
"    Vec3 color;\n"
"} Material;"
""
"typedef struct {\n"
"    uint32_t materialIndex;\n"
"    Vec3 normal;\n"
"    float distanceFromOrigin;\n"
"} Plane;"
""
"typedef struct {\n"
"    uint32_t materialIndex;\n"
"    Vec3 position;\n"
"    float radius;\n"
"} Sphere;"
""
"typedef struct {\n"
"    uint32_t materialIndex;\n"
"    Vec3 v0, v1, v2;\n"
"} Triangle;"
""
"typedef struct {\n"
"    Vec3 position;\n"
"    Vec3 emissionColor;\n"
"    float strength;\n"
"} PointLight;"
"\n"
"typedef struct {\n"
"    uint32_t width, height;\n"
"    uint32_t* buffer; // Stores the data as rgba top to bottom, left to right\n"
"    uint32_t bufferSize;\n"
"} Image;"
""
"typedef struct {\n"
"    Vec3 origin;\n"
"    Vec3 direction;\n"
"} Ray;\n"
"#define EPSILON 0.00001f\n"
"static Vec3 raytracer_refract(Vec3 direction, Vec3 normal, float refractionIndex) {\n"
"    float cosi = math_clamp(-1, 1, vec3_dot(direction, normal));\n"
"    // refractionIndex of air is ~ 1\n"
"    float etai = 1; float etat = refractionIndex;\n"
"    Vec3 n = normal;\n"
"    if (cosi < 0) {\n"
"        cosi = -cosi;\n"
"    } else {\n"
"        float tmp = etai;\n"
"        etai = etat;\n"
"        etat = tmp;\n"
"        n = vec3_mul(n, -1);\n"
"    }\n"
"    float eta = etai / etat;\n"
"    float k = 1 - eta * eta * (1 - cosi * cosi);\n"
"\n"
"    Vec3 refractedDir;\n"
"    if (k < 0) {\n"
"        refractedDir;\n"
"        refractedDir.x = 0.0f;\n"
"        refractedDir.y = 0.0f;\n"
"        refractedDir.z = 0.0f;\n"
"    } else {\n"
"        refractedDir = vec3_norm(vec3_add(vec3_mul(direction, eta), vec3_mul(n, eta * cosi - sqrt(k))));\n"
"    }\n"
"    return refractedDir;\n"
"}\n"
"\n"
"static float raytracer_fresnel(Vec3 dir, Vec3 normal, float refractionIndex) {\n"
"    float kr;\n"
"    float cosi = math_clamp(-1, 1, vec3_dot(dir, normal));\n"
"    float etai = 1;\n"
"    float etat = refractionIndex;\n"
"    if (cosi > 0) {\n"
"        float tmp = etat;\n"
"        etat = etai;\n"
"        etai = tmp;\n"
"    }\n"
"    // Snell's law\n"
"    float sint = etai / etat * sqrt(MAX(0.f, 1.0f - cosi * cosi));\n"
"    if (sint >= 1) {\n"
"        kr = 1;\n"
"    } else {\n"
"        float cost = sqrt(MAX(0.f, 1.0f - sint * sint));\n"
"        cosi = fabs(cosi);\n"
"        float Rs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost));\n"
"        float Rp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost));\n"
"        kr = (Rs * Rs + Rp * Rp) / 2;\n"
"    }\n"
"    return kr;\n"
"}\n"
"\n"
"static Vec3 raytracer_calculateHitpoint(Ray* ray, float hitDistance) {\n"
"    return vec3_add(ray->origin, vec3_mul(ray->direction, hitDistance));\n"
"}\n"
"\n"
"/*\n"
" * Moves the ray origin slightly forward to prevent self intersection\n"
" * also called \"surface agne\"\n"
" */\n"
"static void raytracer_moveRayOutOfObject(Ray* ray) {\n"
"    ray->origin = vec3_add(ray->origin, vec3_mul(ray->direction, 1.0f/1000.0f));\n"
"}\n"
"\n"
"static bool raytracer_intersectPlane(__global Plane* plane, Ray* ray, float* hitDistance, Vec3* intersectionNormal) {\n"
"        // We use the \"Hesse normal form\":\n"
"        //     normal * p - distanceFromOrigin = 0\n"
"        // to describe our planes\n"
"        float denominator = vec3_dot(plane->normal, ray->direction);\n"
"        if ((denominator < -EPSILON) || (denominator > EPSILON)) {\n"
"            float cosAngle = vec3_dot(plane->normal, ray->origin);\n"
"            float t = (-plane->distanceFromOrigin - cosAngle) / denominator;\n"
"            // only hit objects in front of us\n"
"            if (t > 0) {\n"
"                *intersectionNormal = plane->normal;\n"
"                *hitDistance = t;\n"
"                return true;\n"
"            }\n"
"        }\n"
"        return false;\n"
"}\n"
"\n"
"static bool raytracer_intersectSphere(__global Sphere* sphere, Ray* ray, float* hitDistance, Vec3* intersectionNormal) {\n"
"        Vec3 sphereRelativeOrigin = vec3_sub(ray->origin, sphere->position);\n"
"\n"
"        // Mitternachtsformel\n"
"        float a = vec3_dot(ray->direction, ray->direction);\n"
"        float b = 2.0f * vec3_dot(ray->direction, sphereRelativeOrigin);\n"
"        float c = vec3_dot(sphereRelativeOrigin, sphereRelativeOrigin) - sphere->radius * sphere->radius;\n"
"\n"
"        float denominator = 2.0f * a;\n"
"        float squareRootTerm = sqrt(b*b - 4.0f * a * c);\n"
"\n"
"        if (squareRootTerm > EPSILON) {\n"
"            float tpos = (-b + squareRootTerm) / denominator;\n"
"            float tneg = (-b - squareRootTerm) / denominator;\n"
"\n"
"            float t = tpos;\n"
"            // only hit objects in front of us,\n"
"            if ((tneg > 0) && (tneg < tpos)) {\n"
"                t = tneg;\n"
"            }\n"
"            if (t > 0) {\n"
"                Vec3 hitPoint = raytracer_calculateHitpoint(ray, t);\n"
"                *intersectionNormal = vec3_norm(vec3_sub(hitPoint, sphere->position));\n"
"                *hitDistance = t;\n"
"                return true;\n"
"            }\n"
"        }\n"
"\t\treturn false;\n"
"}\n"
"\n"
"static bool raytracer_intersectTriangle(__global Triangle* triangle, Ray* ray, float* hitDistance, Vec3* intersectionNormal) {\n"
"    Vec3 v0v1 = vec3_sub(triangle->v1, triangle->v0);\n"
"    Vec3 v0v2 = vec3_sub(triangle->v2, triangle->v0);\n"
"    Vec3 normal = vec3_norm(vec3_cross(v0v1, v0v2));\n"
"    float normalDotRayDir = vec3_dot(normal, ray->direction);\n"
"    if (fabs(normalDotRayDir) < EPSILON) {\n"
"        return false;\n"
"    }\n"
"\n"
"    float d = vec3_dot(normal, triangle->v0);\n"
"\tfloat t = -(vec3_dot(normal, ray->origin) - d) / normalDotRayDir;\n"
"    if (t > 0) {\n"
"        Vec3 hitPoint = raytracer_calculateHitpoint(ray, t);\n"
"\n"
"        // difference to the plane test\n"
"        Vec3 c;\n"
"\n"
"        Vec3 edge0 = vec3_sub(triangle->v1, triangle->v0);\n"
"        Vec3 vp0 = vec3_sub(hitPoint, triangle->v0);\n"
"        c = vec3_cross(edge0, vp0);\n"
"        if (vec3_dot(normal, c) < 0) {\n"
"            return false;\n"
"        }\n"
"\n"
"        Vec3 edge1 = vec3_sub(triangle->v2, triangle->v1);\n"
"        Vec3 vp1 = vec3_sub(hitPoint, triangle->v1);\n"
"        c = vec3_cross(edge1, vp1);\n"
"        if (vec3_dot(normal, c) < 0) {\n"
"            return false;\n"
"        }\n"
"\n"
"        Vec3 edge2 = vec3_sub(triangle->v0, triangle->v2);\n"
"        Vec3 vp2 = vec3_sub(hitPoint, triangle->v2);\n"
"        c = vec3_cross(edge2, vp2);\n"
"        if (vec3_dot(normal, c) < 0) {\n"
"            return false;\n"
"        }\n"
"\n"
"        *intersectionNormal = normal;\n"
"        *hitDistance = t;\n"
"        return true;\n"
"    }\n"
"    return false;\n"
"}\n"
"\n"
"static void raytracer_calcClosestPlaneIntersect(__global Plane* planes, uint32_t planeCount, Ray* ray, float* minHitDistance, Vec3* intersectionNormal,\n"
"                                                uint32_t* hitMaterialIndex) {\n"
"    for (uint32_t i = 0; i < planeCount; i++) {\n"
"        __global Plane* plane = &planes[i];\n"
"        float planeHitDistance = FLT_MAX;\n"
"        Vec3 planeIntersectionNormal;\n"
"        if (raytracer_intersectPlane(plane, ray, &planeHitDistance, &planeIntersectionNormal)) {\n"
"            if (planeHitDistance < *minHitDistance) {\n"
"                *intersectionNormal = planeIntersectionNormal;\n"
"                *minHitDistance = planeHitDistance;\n"
"                *hitMaterialIndex = plane->materialIndex;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"static void raytracer_calcClosestSphereIntersect(__global Sphere* spheres, uint32_t sphereCount, Ray *ray, float* minHitDistance, Vec3* intersectionNormal,\n"
"                                                 uint32_t* hitMaterialIndex) {\n"
"    for (uint32_t i = 0; i < sphereCount; i++) {\n"
"        __global Sphere* sphere = &spheres[i];\n"
"        float sphereHitDistance = FLT_MAX;\n"
"        Vec3 sphereIntersectionNormal;\n"
"        if (raytracer_intersectSphere(sphere, ray, &sphereHitDistance, &sphereIntersectionNormal)) {\n"
"            if (sphereHitDistance < *minHitDistance) {\n"
"                *intersectionNormal = sphereIntersectionNormal;\n"
"                *minHitDistance = sphereHitDistance;\n"
"                *hitMaterialIndex = sphere->materialIndex;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"static void raytracer_calcClosestTriangleIntersect(__global Triangle* triangles, uint32_t triangleCount, Ray* ray, float* minHitDistance, Vec3* intersectionNormal,\n"
"                                                   uint32_t* hitMaterialIndex) {\n"
"    for (uint32_t i = 0; i < triangleCount; i++) {\n"
"        __global Triangle* triangle = &triangles[i];\n"
"        float triangleHitDistance = FLT_MAX;\n"
"        Vec3 triangleIntersectionNormal;\n"
"        if (raytracer_intersectTriangle(triangle, ray, &triangleHitDistance, &triangleIntersectionNormal)) {\n"
"            if (triangleHitDistance < *minHitDistance) {\n"
"                *intersectionNormal = triangleIntersectionNormal;\n"
"                *minHitDistance = triangleHitDistance;\n"
"                *hitMaterialIndex = triangle->materialIndex;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"static Vec3 raytracer_raycast_helper(__global Camera* camera, __global Material* materials, uint32_t materialCount, __global Plane* planes, uint32_t planeCount, __global Sphere* spheres, uint32_t sphereCount, __global Triangle* triangles, uint32_t triangleCount, __global PointLight* pointLights, uint32_t pointLightCount, Ray* primaryRay, uint32_t recursionDepth, uint32_t maxRecursionDepth) {\n"
"    Vec3 outColor;\n"
"    outColor.r = 0.0f;\n"
"    outColor.g = 0.0f;\n"
"    outColor.b = 0.0f;\n"
"\n"
"    if (recursionDepth >= maxRecursionDepth) {\n"
"        return outColor;\n"
"    }\n"
"\n"
"    float minHitDistance = FLT_MAX;\n"
"    uint32_t hitMaterialIndex = 0;\n"
"\n"
"    Vec3 intersectionNormal;\n"
"\n"
"    raytracer_calcClosestPlaneIntersect(planes, planeCount, primaryRay, &minHitDistance, &intersectionNormal, &hitMaterialIndex);\n"
"    raytracer_calcClosestSphereIntersect(spheres, sphereCount, primaryRay, &minHitDistance, &intersectionNormal, &hitMaterialIndex);\n"
"    raytracer_calcClosestTriangleIntersect(triangles, triangleCount, primaryRay, &minHitDistance, &intersectionNormal, &hitMaterialIndex);\n"
"\n"
"    if (hitMaterialIndex) {\n"
"\n"
"        __global Material* hitMaterial = &materials[hitMaterialIndex];\n"
"\n"
"\t\t// if we got a hit, calculate the hitPoint and send a shadow rays to each lightsource\n"
"\t\tVec3 hitPoint = raytracer_calculateHitpoint(primaryRay, minHitDistance);\n"
"\n"
"\t\t// REFLECTION AND REFRACTION\n"
"\t\tif (hitMaterial->refractionIndex > 0) {\n"
"\t\t    float kr = raytracer_fresnel(primaryRay->direction, intersectionNormal, hitMaterial->refractionIndex);\n"
"\n"
"            Vec3 refractionColor;\n"
"            refractionColor.r = 0.0f;\n"
"            refractionColor.g = 0.0f;\n"
"            refractionColor.b = 0.0f;\n"
"\n"
"            // compute refraction if it is not a case of total internal reflection\n"
"            if (kr < 1) {\n"
"                Ray refractedRay;\n"
"                refractedRay.origin = hitPoint;\n"
"                refractedRay.direction = raytracer_refract(primaryRay->direction, intersectionNormal, hitMaterial->refractionIndex);\n"
"                raytracer_moveRayOutOfObject(&refractedRay);\n"
"\n"
"                refractionColor = raytracer_raycast_helper(camera, materials, materialCount, planes, planeCount, spheres, sphereCount, triangles, triangleCount, pointLights, pointLightCount, &refractedRay, recursionDepth + 1, maxRecursionDepth);\n"
"            }\n"
"\n"
"            Ray reflectedRay;\n"
"            reflectedRay.origin = hitPoint;\n"
"            reflectedRay.direction = vec3_reflect(primaryRay->direction, intersectionNormal);\n"
"            raytracer_moveRayOutOfObject(&reflectedRay);\n"
"\n"
"            Vec3 reflectionColor = raytracer_raycast_helper(camera, materials, materialCount, planes, planeCount, spheres, sphereCount, triangles, triangleCount, pointLights, pointLightCount, &reflectedRay, recursionDepth + 1, maxRecursionDepth);\n"
"\n"
"            // mix the two\n"
"            outColor = vec3_add(outColor, vec3_add(vec3_mul(reflectionColor, kr), vec3_mul(refractionColor, (1 - kr))));\n"
"        } else\n"
"\t\t// REFLECTION:\n"
"\t\tif (hitMaterial->reflectionIndex > 0) {\n"
"\n"
"\t\t\tRay reflectedRay;\n"
"            reflectedRay.origin = hitPoint;\n"
"            reflectedRay.direction = vec3_reflect(primaryRay->direction, intersectionNormal);\n"
"            raytracer_moveRayOutOfObject(&reflectedRay);\n"
"\n"
"\t\t\tVec3 reflectionColor = raytracer_raycast_helper(camera, materials, materialCount, planes, planeCount, spheres, sphereCount, triangles, triangleCount, pointLights, pointLightCount, &reflectedRay, recursionDepth + 1, maxRecursionDepth);\n"
"\n"
"\t\t\toutColor = vec3_add(outColor, vec3_mul(reflectionColor, hitMaterial->reflectionIndex));\n"
"\t\t}\n"
"\n"
"\t\t// SHADOWS\n"
"        for (uint32_t i = 0; i < pointLightCount; i++) {\n"
"            __global PointLight* pointLight = &pointLights[i];\n"
"            Ray shadowRay;\n"
"            Vec3 hitToLight = vec3_sub(pointLight->position, hitPoint);\n"
"            // Vec3 randomOffset = vec3_norm((Vec3) { random_bilateral(), random_bilateral(), random_bilateral()});\n"
"            // hitToLight = vec3_add(hitToLight, randomOffset);\n"
"            float distanceToLight = vec3_length(hitToLight);\n"
"\n"
"            shadowRay.origin = hitPoint;\n"
"            shadowRay.direction = vec3_norm(hitToLight);\n"
"            raytracer_moveRayOutOfObject(&shadowRay);\n"
"\n"
"            uint32_t shadowRayHitMaterialIndex = 0;\n"
"            float closestHitDistance = FLT_MAX;\n"
"            Vec3 shadowRayIntersectionNormal;\n"
"            raytracer_calcClosestPlaneIntersect(planes, planeCount, &shadowRay, &closestHitDistance, &shadowRayIntersectionNormal, &shadowRayHitMaterialIndex);\n"
"            raytracer_calcClosestSphereIntersect(spheres, sphereCount, &shadowRay, &closestHitDistance, &shadowRayIntersectionNormal, &shadowRayHitMaterialIndex);\n"
"            raytracer_calcClosestTriangleIntersect(triangles, triangleCount, &shadowRay, &closestHitDistance, &shadowRayIntersectionNormal, &shadowRayHitMaterialIndex);\n"
"            if (distanceToLight < closestHitDistance) {\n"
"                // we hit the light\n"
"                float cosAngle = vec3_dot(shadowRay.direction, intersectionNormal);\n"
"                cosAngle = math_clamp(cosAngle, 0.0f, 1.0f);\n"
"\n"
"                float lightStrength = (pointLight->strength/(4 * PI * distanceToLight * distanceToLight));\n"
"                Vec3 diffuseLighting = vec3_mul(pointLight->emissionColor, cosAngle * lightStrength);\n"
"\n"
"                Vec3 toView = vec3_norm(vec3_sub(camera->position, hitPoint));\n"
"                Vec3 toLight = vec3_mul(shadowRay.direction, -1);\n"
"                Vec3 reflectionVector = vec3_reflect(toLight, intersectionNormal);\n"
"                cosAngle = vec3_dot(toView, reflectionVector);\n"
"                cosAngle = pow(cosAngle, 64);\n"
"\n"
"                Vec3 specularLighting = vec3_mul(pointLight->emissionColor, cosAngle * lightStrength);\n"
"\n"
"                outColor = vec3_add(outColor, vec3_mul(vec3_add(diffuseLighting, specularLighting), (1-hitMaterial->reflectionIndex)));\n"
"            }\n"
"        }\n"
"        outColor = vec3_hadamard(outColor, hitMaterial->color);\n"
"    }\n"
"    return outColor;\n"
"}\n"
"\n"
"Vec3 raytracer_raycast(__global Camera* camera, __global Material* materials, uint32_t materialCount, __global Plane* planes, uint32_t planeCount, __global Sphere* spheres, uint32_t sphereCount, __global Triangle* triangles, uint32_t triangleCount, __global PointLight* pointLights, uint32_t pointLightCount, Ray* primaryRay, uint32_t maxRecursionDepth) {\n"
"    return raytracer_raycast_helper(camera, materials, materialCount, planes, planeCount, spheres, sphereCount, triangles, triangleCount, pointLights, pointLightCount, primaryRay, 0, maxRecursionDepth);\n"
"}"
""
""
"__kernel void raytrace(__global Camera* camera, __global Material* materials, uint32_t materialCount, "
"                       __global Plane* planes, uint32_t planeCount, __global Sphere* spheres, uint32_t sphereCount, "
"                       __global Triangle* triangles, uint32_t triangleCount, __global PointLight* pointLights, uint32_t pointLightCount, "
"                       __global uint32_t* image, uint32_t maxRecursionDepth, float rayColorContribution, float deltaX, float deltaY, "
"                       float pixelWidth, float pixelHeight, uint32_t raysPerWidthPixel, uint32_t raysPerHeightPixel) {"
"   uint32_t x = get_global_id(0);\n"
"   uint32_t width = camera->width;\n"
"   uint32_t y = get_global_id(1);\n"
"   float PosY = -1.0f + 2.0f * ((float)y / (camera->height));\n"
"   float PosX = -1.0f + 2.0f * ((float)x / (camera->width));\n"
"   Vec3 color;\n"
"   color.r = 0.0f;\n"
"   color.g = 0.0f;\n"
"   color.b = 0.0f;\n"
"   // Supersampling loops\n"
"   for (uint32_t j = 0; j < raysPerHeightPixel; j++) {\n"
"       for (uint32_t i = 0; i < raysPerWidthPixel; i++) {\n"
"           Vec3 OffsetY = vec3_mul(camera->y,\n"
"               (PosY - pixelHeight + j * deltaY)*camera->renderTargetHeight/2.0f);\n"
"           Vec3 OffsetX = vec3_mul(camera->x,\n"
"               (PosX - pixelWidth + i * deltaX)*camera->renderTargetWidth/2.0f);\n"
"           Vec3 renderTargetPos = vec3_sub(vec3_add(camera->renderTargetCenter, OffsetX), OffsetY);\n"
"           Ray ray = {\n"
"               camera->position,\n"
"               vec3_norm(vec3_sub(renderTargetPos, camera->position))\n"
"           };\n"
"\n"
"           Vec3 currentRayColor = raytracer_raycast(camera, materials, materialCount, planes, planeCount, spheres, sphereCount, triangles, triangleCount, pointLights, pointLightCount, &ray, maxRecursionDepth);\n"
"           color = vec3_add(color, vec3_mul(currentRayColor, rayColorContribution));\n"
"       }\n"
"   }\n"
"\n"
"            // currently values are clamped to [0,1]\n"
"            // in the future we may return floats > 1.0\n"
"            // and use hdr to map it back to the [0.0, 1.0] range after\n"
"            // all pixels are calculated\n"
"            // this would avoid that really bright areas look the \"same\"\n"
"            color = vec3_clamp(color, 0.0f, 1.0f);\n"
"\n"
"   image[y*width + x] = \n"
"           (0xFFu << 24) |\n"
"           ((uint32_t)(color.r * 255) << 16) |\n"
"           ((uint32_t)(color.g * 255) << 8) |\n"
"           ((uint32_t)(color.b * 255) << 0);\n"
"}";

typedef struct {
    cl_platform_id plat;
    cl_device_id dev;
    cl_context ctx;
    cl_command_queue command_queue;
    cl_program prog;
    cl_int err;
} oclContext;

oclContext* initOpenClContext() {
    oclContext* context = malloc(sizeof(oclContext));
    clGetPlatformIDs(1, &context->plat, NULL);
    clGetDeviceIDs(context->plat, CL_DEVICE_TYPE_GPU, 1, &context->dev, NULL);
    context->ctx = clCreateContext(0, 1, &context->dev, NULL, NULL, &context->err);
    context->command_queue = clCreateCommandQueueWithProperties(context->ctx, context->dev, 0, &context->err);

    size_t sourceSize = strlen(kernelSource);
    context->prog = clCreateProgramWithSource(context->ctx, 1, &kernelSource, &sourceSize, &context->err);
    clBuildProgram(context->prog, 1, &context->dev, NULL, NULL, NULL);
#ifndef NDEBUG
    cl_build_status status;
    clGetProgramBuildInfo(context->prog, context->dev, CL_PROGRAM_BUILD_STATUS, sizeof(cl_build_status), &status, NULL);
    if (status != CL_BUILD_SUCCESS) {
        char* log;
        size_t log_size = 0;

        // get the size of the log
        clGetProgramBuildInfo(context->prog, context->dev, CL_PROGRAM_BUILD_LOG, 0, NULL, &log_size);

        log = malloc(sizeof(char) * (log_size + 1));
        // get the log itself
        clGetProgramBuildInfo(context->prog, context->dev, CL_PROGRAM_BUILD_LOG, log_size, log, NULL);
        log[log_size] = '\0';
        // print the log
        printf("Build log:\n%s\n", log);
        free(log);
        return NULL;
    }
#endif
    return context;
}

#include "utils/image.h"
#include "scene.h"

cl_mem image_create_gpu(oclContext* oclContext, Image* image) {
    cl_mem dev_image = clCreateBuffer(oclContext->ctx, CL_MEM_WRITE_ONLY, sizeof(uint32_t) * image->width * image->height, image->buffer, &oclContext->err);
    if (oclContext->err != CL_SUCCESS) {
        printf("Couldn't create dev_image.\n");
        return NULL;
    }
    return dev_image;
}

cl_mem scene_create_gpu_camera(oclContext* oclContext, Scene* scene) {
    cl_mem dev_camera = (void*) clCreateBuffer(oclContext->ctx, CL_MEM_READ_WRITE | CL_MEM_COPY_HOST_PTR, sizeof(Camera), scene->camera, &oclContext->err);
    if (oclContext->err != CL_SUCCESS) {
        printf("Couldn't create dev_camera.\n");
        return NULL;
    }
    return dev_camera;
}

cl_mem scene_create_gpu_materials(oclContext* oclContext, Scene* scene) {
    cl_mem dev_materials = (void*) clCreateBuffer(oclContext->ctx, CL_MEM_READ_WRITE | CL_MEM_COPY_HOST_PTR, sizeof(Material) * scene->materialCount, scene->materials, &oclContext->err);
    if (oclContext->err != CL_SUCCESS) {
        printf("Couldn't create dev_materials.\n");
        return NULL;
    }
    return dev_materials;
}

cl_mem scene_create_gpu_planes(oclContext* oclContext, Scene* scene) {
    cl_mem dev_planes = (void*) clCreateBuffer(oclContext->ctx, CL_MEM_READ_WRITE | CL_MEM_COPY_HOST_PTR, sizeof(Plane) * scene->planeCount, scene->planes, &oclContext->err);
    if (oclContext->err != CL_SUCCESS) {
        printf("Couldn't create dev_planes.\n");
        return NULL;
    }
    return dev_planes;
}

cl_mem scene_create_gpu_spheres(oclContext* oclContext, Scene* scene) {
    cl_mem dev_spheres = (void*) clCreateBuffer(oclContext->ctx, CL_MEM_READ_WRITE | CL_MEM_COPY_HOST_PTR, sizeof(Sphere) * scene->sphereCount, scene->spheres, &oclContext->err);
    if (oclContext->err != CL_SUCCESS) {
        printf("Couldn't create dev_spheres.\n");
        return NULL;
    }
    return dev_spheres;
}

cl_mem scene_create_gpu_triangles(oclContext* oclContext, Scene* scene) {
    cl_mem dev_triangles = (void*) clCreateBuffer(oclContext->ctx, CL_MEM_READ_WRITE | CL_MEM_COPY_HOST_PTR, sizeof(Triangle) * scene->triangleCount, scene->triangles, &oclContext->err);
    if (oclContext->err != CL_SUCCESS) {
        printf("Couldn't create dev_triangles.\n");
        return NULL;
    }
    return dev_triangles;
}

cl_mem scene_create_gpu_pointLights(oclContext *oclContext, Scene *scene) {
    cl_mem dev_pointLights = (void*) clCreateBuffer(oclContext->ctx, CL_MEM_READ_WRITE | CL_MEM_COPY_HOST_PTR, sizeof(PointLight) * scene->pointLightCount, scene->pointLights, &oclContext->err);
    if (oclContext->err != CL_SUCCESS) {
        printf("Couldn't create dev_pointlights.\n");
        return NULL;
    }
    return dev_pointLights;
}

void destroyOpenClContext(oclContext* oclContext) {
    if (oclContext) {
        clReleaseProgram(oclContext->prog);
        clReleaseCommandQueue(oclContext->command_queue);
        clReleaseContext(oclContext->ctx);
        free(oclContext);
    }
}


#endif //RAYTRACER_KERNEL_H
